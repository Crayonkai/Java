[toc]



## Redis

1. 五种数据类型：String、list、set、hash、zset
2. 持久化方式：RDB：全量数据备份，优点是文件小，加载快，恢复快，对redis性能影响小；AOF:支持秒级持久化，不容易丢失数据，缺点是文件大，对性能影响大
3. 缓存穿透：缓存中没有该数据，每次查询都会穿过缓存直接查DB，影响DB性能；解决办法：DB返回空也进行缓存，设置较短的失效时间，这样可以减少对DB的访问，利用布隆过滤器，见可能失效数据存到一个大的bitmap里，每次查询把无用数据过滤掉。
4. 缓存击穿：当缓存中某个key值刚好失效的同时，大量请求进来访问该key，这些请求会直接到DB，导致DB崩溃；解决办法：使用互斥锁或设置key永远不过期（异步查数据库更新）
5. 缓存雪崩：多个key在同一时间过期，导致大量访问直接到DB，DB负载过大；解决方法：是指不同的失效时间，或设置相同失效时间后面跟一个随机值（1-5分钟），把失效时间分散开
6. 缓存击穿是一个key失效后大量访问请求该key；缓存雪崩是多个key在同一时间失效，大量访问请求不同key都请求到DB。



































## JVM





































## 多线程

### 线程的六种状态：

NEW：新建

RUNNABLE：可执行

BLOCKED：阻塞

WAITING：等待

TIMED_WAITING：即时等待

TERMINALED：终止



























## String

jdk1.8及以前版本底层是char数组，9以后改为byte数组，目的是节省内存，由2个字节变为1个字节。但涉及汉子和一些1个字节无法存储的字符还是会选用UTF-16用2个字节，由一个布尔变量coder控制。

char[] 或 byte[] 由final修饰，为不可变，线程安全。























## mysql

### sql的执行过程

1. 连接器，判断用户身份信息是否正确，是否有权限。
2. 根据用户上送的sql查询缓存，mysql缓存要求的是sql必须一模一样才会命中缓存，否则缓存查不到。mysql8开始移除了查询缓存
3. 解析和预处理，讲sql解析成抽象语法树(AST)，并做预处理，会检查所查询表是否存在，是否有语法错误
4. 优化器，会根据解析树生成多种优化后的执行计划，mysql会选择一种最优的执行。
5. 执行器，执行解析后的sql，获取结果，返回给客户端。

### 索引

1. 数据结构是B+树。

   B+树特点：所有非叶子节点只存键和指针，叶子结点存键和值，并且叶子结点之间有链指针

   B树是所有节点都存键值，叶子结点之间无指针

2. 组合索引有最左前缀原则。mysql由最左的字段构建B+索引树，如果查询没有最左的字段则无法应用到索引。如果组合索引查询时全部用=则可以无序，优化器会按索引顺序执行。如果条件之中有范围查找则停止。比如abcd索引，a=1,b=1,c>3,d=1;则d索引没有使用到。

3. force index() 强制使用索引。如果一个表有多个索引。条件也用到了多个字索引字段，mysql优化器可能选取的并不是最优索引。可以手动强制使用某个索引。相对的就有ignore index()强制不适用某个索引，或某几个索引。

4. explain执行计划的type：

   system系统表>const常量连接>eq_ref唯一索引>ref非唯一索引>range索引范围查找>index索引全部扫描>all全表扫描

5. 

















































